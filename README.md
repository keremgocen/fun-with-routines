[![CircleCI](https://circleci.com/gh/keremgocen/fun-with-routines.svg?style=svg)](https://circleci.com/gh/keremgocen/fun-with-routines)
# fun-with-routines

How to run locally
-----

```
docker build -t fwr .
docker run --name test --rm fwr
```

Run tests
-----
(after building the image)

```
docker run -it fwr go test -v github.com/keremgocen/fun-with-routines
```

Notes on my approach
-----
Both problem functions are modified to enable unit testing on them.

### Problem1
A `taskCount int` should be provided to the function `problem1()` to determine the number of random values to be printed.

A `jobs` channel then gets populated with job ids (ie. from 1 to 100) and go routines use this channel to coordinate. If a value is present in the channel, a random value is printed. This works as expected despite the number of go routines spawned or the size of loop in them.

For testing `problem1()`, generated values are written into a separate channel that is being read by the main process synchronously. It's length is then compared with the expected value in `problem1_test.go`.

### Problem2
A `taskCount int` should be provided to the function `problem2()` as well. The task details of printing a random value to stdout is represented by a struct;

```
type task struct {
	id int // task id
	slot int // go routine slot running the task
	loop int // inner loop count inside the go routine
	num float32 // the number generated by the task 
}
``` 
Same as in problem1, jobs channels for go routines are populated with task ids and the tasks channel is passed in to fan-in results in the main process. 

For testing `problem2()`, a `time.Tick` channel is used to limit the rate main process is reading the results from tasks channel. One result is read every second and the timestamp is recorded. Then in `problem2_test.go` timestamps are compared against consecutive tasks and the difference is expected to be between 0.9 and 1.1 seconds.  
